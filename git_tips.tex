\documentclass{article}
\usepackage[dvipsnames]{xcolor}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{subfig}
\usetikzlibrary{positioning}
\usepackage{caption}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Git tips},
    pdfpagemode=FullScreen,
}

\title{Some (hopefully) helpful tips for using git}
\author{Mateusz Krajewski}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Introduction} 
It is of paramount importance that we use git in an organised and consistent manner. It will reduce confusion and make it easier to mitigate the consequences of our mistakes. And there will be plenty, inevitably. The following is my attempt to standardise our git workflow. Feel free to share this document and adjust it to Your needs -- just remember to keep my name in. \hyperref[sec:contributing]{Contributions} will be appreciated.

In order to make the branch history as clean as possible, we have decided to create seven separate branches - one for every team member. Every developer is going to work on their issues on the branch assigned to them - and merge it with main when necessary.

I am going to present a couple of common scenarios that can arise when working with git. I tried to make it as relatable to the current project as possible. For that reason, all the examples below are based solely in Eclipse IDE. I may include some command-line examples later on.

\section{The development process}

The following is the general overview of our development process. You should try to adhere to it as much as possible. To explore the steps in more details, refer to the later parts of this document.

\begin{enumerate}
	\item Start working on the issue on Your own branch.
	\item Remember to commit and push regularly, so that other team members can review Your changes.
	\item Your work is only done when Your code reviewer says so.
	\item In order to merge, first make sure that Your local main branch is up-to-date with the remote one. In order to do that, \hyperref[sec:switching]{switch} to main branch and \hyperref[sec:pulling]{pull} from the remote.
	\item Then, \hyperref[sec:merging]{merge} Your branch into main. Solve any \hyperref[sec:conflicts]{conflicts} that may arise.
	\item Close the issue in the issue tracker.
\end{enumerate}

\section{Miscellany}

\subsection{Git staging}
\label{sec:git_staging}

There are two helpful views that You can enable in order to better understand what's going on. One of them is \textit{Git staging}. You'll find it in: \newline

$\mathtt{Window\rightarrow Show\ view \rightarrow Other \rightarrow Git \rightarrow Git\ Staging}$.\newline

It's an easy tool for reviewing the changes You have made, and ultimately committing them.

\subsection{History}
\label{sec:git_history}

You can find \textit{History} view under: \newline

$\mathtt{Window \rightarrow Show\ view \rightarrow Other \rightarrow Team \rightarrow History}$.\newline

It shows the history of changes made to the chosen resource in the \textit{Package Explorer}. Besides, it makes it extremely simple to see the state of current branches, both local and remote.

\subsection{Current branch}

The branch You're currently in is displayed right next to the project name in \textit{Package Explorer} (Figure  \ref{fig:branch_name}). You almost certainly know this. But if I want to make this document as comprehensive as possible, it needs to be here.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.6]{branch_name.png}
    \caption{The location of the current branch name.}
    \label{fig:branch_name}
\end{figure}

\subsection{Pulling}
\label{sec:pulling}

In order to synchronise Your local branch with any changes made to its remote counterpart, right-click the project name and choose

$\mathtt{Team \rightarrow Pull}$. \newline

Most likely, You will have to choose between two identical \textit{Pull} options. The only difference is that the second one goes into the process in more detail. Ultimately, though, it doesn't really matter which one You'll pick.

\section{Moving between branches}
\label{sec:switching}

This is probably basic knowledge as well. In Eclipse, You can switch between branches/commits by right-clicking the project name in the \textit{Package Explorer} and choosing:\newline

$\mathtt{Team \rightarrow Switch\ to}$.\newline

With the help of this tool, it is possible to:

\begin{itemize}
    \item create a new local branch;
    \item create a local copy of a remote branch;
    \item switch between local branches;
    \item switch between commits.
\end{itemize}

\textbf{NOTE: } Before You do any of that, make sure to look into \hyperref[sec:git_staging]{Git staging} and commit any changes You have made so far. Otherwise, git may behave unpredictably and You will spend the next two hours trying to figure out what to do (it certainly never happened to me, duh). 

\section{Updating the feature branch}

Suppose You started working on Your branch and already made some commits. In the meantime, however, one of Your teammates merged their work into main and now Your branch is outdated. In such a case, the commit graph may look (roughly) like in Figure \ref{fig:before_update}. You may want to update Your branch and keep working on it, without having to merge into main (not yet, at least). In order to do that, You can do the opposite - merge main into Your branch. This operation would result in creating a new merge commit, just like in Figure \ref{fig:after_update}.\newline

\begin{minipage}[b]{0.45\textwidth}
\begin{tikzpicture}[
    mainnode/.style={circle, draw=green!60, fill=green!5, very thick, minimum size=7mm},
    branchnode/.style={circle, draw=red!60, fill=red!5, very thick, minimum size=7mm}
]
\node[mainnode](main){};
\node[mainnode](main2)[above=of main]{};
\node[mainnode](main3)[above=of main2, label=right:\textcolor{OliveGreen}{$\mathtt{main}$}]{};
\node[branchnode](branch)[left=of main2]{};
\node[branchnode](branch2)[above=of branch, label=left:\textcolor{BrickRed}{$\mathtt{branch}$}]{};
\draw[->] (main.north) -- (main2.south);
\draw[->] (main2.north) -- (main3.south);
\draw[->] (main.west) .. controls +(left:2mm) and +(down:4mm) .. (branch.south);
\draw[->] (branch.north) -- (branch2.south);
\end{tikzpicture}
\captionof{figure}{Before updating.}
\label{fig:before_update}
\end{minipage}
\hspace{0.1\textwidth}
\begin{minipage}[b]{0.45\textwidth}
\begin{tikzpicture}[
    mainnode/.style={circle, draw=green!60, fill=green!5, very thick, minimum size=7mm},
    branchnode/.style={circle, draw=red!60, fill=red!5, very thick, minimum size=7mm}
]
\node[mainnode](main){};
\node[mainnode](main2)[above=of main]{};
\node[mainnode](main3)[above=of main2, label=right:\textcolor{OliveGreen}{$\mathtt{main}$}]{};
\node[branchnode](branch)[left=of main2]{};
\node[branchnode](branch2)[above=of branch]{};
\node[branchnode](branch3)[above=of branch2, label=left:\textcolor{BrickRed}{$\mathtt{branch}$}]{};
\draw[->] (main.north) -- (main2.south);
\draw[->] (main2.north) -- (main3.south);
\draw[->] (main.west) .. controls +(left:2mm) and +(down:4mm) .. (branch.south);
\draw[->] (branch.north) -- (branch2.south);
\draw[->] (branch2.north) -- (branch3.south);
\draw[->] (main3.west) .. controls +(left:2mm) and +(down:4mm) .. (branch3.south);
\end{tikzpicture}
\captionof{figure}{After updating.}
\label{fig:after_update}
\end{minipage}

\paragraph{}
Now, how to do that? The process itself is quite simple. First, make sure that the main branch is synchronised with the remote (\hyperref[sec:switching]{switch} to main and \hyperref[sec:pulling]{pull}). Then, \hyperref[sec:switching]{switch} to the feature branch. Right-click the project name and choose the following:\newline

$\mathtt{Team\rightarrow Merge}.$\newline

After that, select the local main branch. Solve any \hyperref[sec:conflicts]{conflicts} that may arise. Move on.

\subsection{Conflicts with the local main branch}

If there are conflicts, however, things get a little more complicated. Most likely, a window like that in Figure \ref{fig:rebase_result} shows up. It displays the first of Your commits with conflicts detected, as well as the affected files. If You prefer to give Yourself some time to think, choose the \textit{abort rebase} option. Otherwise, if You're feeling daring today and like living life on the edge, \textit{start merge tool to resolve conflicts}.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{rebase_result.png}
    \caption{If there are conflicts during a rebase, this window will show up.}
    \label{fig:rebase_result}
\end{figure}

Next, You will be taken to the \textit{Merge Tool}, as shown in Figure \ref{fig:rebase_merge_tool}. There are three sections here:
\begin{itemize}
    \item The upper section shows the files You need to fix.
    \item The bottom left section shows what the files look like in the last commit in main. This is where You apply Your changes.
    \item The bottom right section shows what the files look like in the first conflicting commit of Your branch. You can't change anything here.
\end{itemize}

After You've made Your changes, stage them in the \textit{Git Staging} view. Next, choose the \textit{Continue} button, just like in Figure \ref{fig:rebase_continue}. If any more of Your commits are in conflict with \textit{main}, You will have to repeat the procedure. Otherwise, the rebasing is done and You can keep working on Your branch (or merge it into main without any conflicts).

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.27]{rebase_merge_tool.png}
    \caption{The Merge Tool shown if there are conflicts during a rebase.}
    \label{fig:rebase_merge_tool}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.27]{rebase_continue.png}
    \caption{The \textit{Git Staging} view shown if there are conflicts during a rebase.}
    \label{fig:rebase_continue}
\end{figure}

\section{Merging with main}
\label{sec:merging}
Merging is really quite simple. Before You do that, however, make sure that Your main branch is up-to-date with the remote one (\hyperref[sec:switching]{switch} to main and \hyperref[sec:pulling]{pull} the remote). After that, right-click the project name and choose:\newline

$\mathtt{Team\rightarrow Merge}$.\newline

Then, select the branch You want to merge into main. No need to meddle with the additional options. Now, if we imagine a commit graph like that in Figure \ref{fig:before_update}, its structure after the merge would be similar to that in Figure \ref{fig:after_merge}. Note how git creates an additional merge commit, which incorporates the changes made both in the main branch and in the feature branch. Any further changes made to the feature branch will result in the graph evolving like in Figure \ref{fig:after_changes}.

If You encounter conflicts, refer to section \ref{sec:conflicts}.\newline

\begin{minipage}[b]{0.45\textwidth}
\begin{tikzpicture}[
    mainnode/.style={circle, draw=green!60, fill=green!5, very thick, minimum size=7mm},
    branchnode/.style={circle, draw=red!60, fill=red!5, very thick, minimum size=7mm}
]
\node[mainnode](main){};
\node[mainnode](main2)[above=of main]{};
\node[mainnode](main3)[above=of main2]{};
\node[mainnode](main4)[above=of main3, label=right:\textcolor{OliveGreen}{$\mathtt{main}$} / \textcolor{BrickRed}{$\mathtt{branch}$}]{};
\node[branchnode](branch)[left=of main2]{};
\node[branchnode](branch2)[above=of branch]{};
\draw[->] (main.north) -- (main2.south);
\draw[->] (main2.north) -- (main3.south);
\draw[->] (main3.north) -- (main4.south);
\draw[->] (main.west) .. controls +(left:2mm) and +(down:4mm) .. (branch.south);
\draw[->] (branch.north) -- (branch2.south);
\draw[->] (branch2.east) .. controls +(right:2mm) and +(down:4mm) .. (main4.south);
\end{tikzpicture}
\captionof{figure}{After merge.}
\label{fig:after_merge}
\end{minipage}
\hspace{0.1\textwidth}
\begin{minipage}[b]{0.45\textwidth}
\begin{tikzpicture}[
    mainnode/.style={circle, draw=green!60, fill=green!5, very thick, minimum size=7mm},
    branchnode/.style={circle, draw=red!60, fill=red!5, very thick, minimum size=7mm}
]
\node[mainnode](main){};
\node[mainnode](main2)[above=of main]{};
\node[mainnode](main3)[above=of main2]{};
\node[mainnode](main4)[above=of main3, label=right:\textcolor{OliveGreen}{$\mathtt{main}$}]{};
\node[branchnode](branch)[left=of main2]{};
\node[branchnode](branch2)[above=of branch]{};
\node[branchnode](branch3)[above=of branch3, label=left:\textcolor{BrickRed}{$\mathtt{branch}$}]{};
\draw[->] (main.north) -- (main2.south);
\draw[->] (main2.north) -- (main3.south);
\draw[->] (main3.north) -- (main4.south);
\draw[->] (main.west) .. controls +(left:2mm) and +(down:4mm) .. (branch.south);
\draw[->] (branch.north) -- (branch2.south);
\draw[->] (branch2.east) .. controls +(right:2mm) and +(down:4mm) .. (main4.south);
\draw[->] (main4.west) .. controls +(left:2mm) and +(down:4mm) .. (branch3.south);
\end{tikzpicture}
\captionof{figure}{After further changes.}
\label{fig:after_changes}
\end{minipage}

\section{Squashing}
\label{sec:squashing}
This is not necessarily useful, but git offers the option to `squeeze' multiple consecutive commits into one. You may want to do it to simplify Your commit history. The process is simple: go to \textit{History} view, ctrl-select the commits You want to squash and right-click them. After that, choose:\newline

$\mathtt{Modify\rightarrow Squash}$.\newline

If You pushed the commits before squashing them, You may be prohibited from pushing again. In such a case, refer to Subsection \ref{fig:push_conflict}.

\section{Conflicts}
\label{sec:conflicts}

If the attempt to merge results in conflicts, it might be worth looking into the \textit{Git Staging} view. The \textit{Staged Changes} window will contain all successfully merged files. The \textit{Unstaged Changes}, in turn, will contain all the files that'll have to be fixed. You can do it either with the \textit{Merge Tool} (refer to section \ref{fig:push_conflict}) or edit every file by Yourself. In the latter case, every conflict is of the form:
\begin{verbatim}
<<<<<<< HEAD
what you see in the main branch
=======
what you see in the feature branch
>>>>>>>
\end{verbatim}
You can choose one of the two options, merge them, or do anything else, really. Just remember to remove the redundant symbols - git won't do it for You! Once You're done, stage and commit Your changes.


\section{Git commit messages}
\label{sec:commit_messages}
I know it's hard, but it is very important to try your best to commit in a standardised and consistent way. Some reasons why: 
\begin{itemize}
    \item You'll be able to track what you are doing better; when you come to work on the project two weeks later a commit message titled \textit{Add search button} will be far more helpful than a commit message titled \textit{Commit 5, I solved the issue}.
    \item When your team members or other people go to work on the repository, they will be able to scan through what you have done and work on your code. 
\end{itemize}

How to do it: 
\begin{enumerate}
    \item Start with an imperative form of the verb i.e. \textit{add, fix, delete};
    \item Start with a capital letter; 
    \item Keep it short;
    \item Provide the concise outline of what You did;
    \item Don't end the commit message with a period. 
\end{enumerate}

\section{Contributing}
\label{sec:contributing}

\section{Acknowledgements}

\end{document}
